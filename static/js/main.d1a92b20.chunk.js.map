{"version":3,"sources":["PathfinderVisualizer/Node/Node.jsx","algorithms/dj.js","PathfinderVisualizer/PathfinderVisualizer.jsx","App.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","start","end","visited","distance","unvisited","nodes","node","push","getAllNodes","length","sortNodesByDistance","closest","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","state","mouseIsPressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","visitedNodesInOrder","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","startNode","finishNode","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","visualizeDijkstra","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d1a92b20.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}","export function dijkstra(grid, start, end) {\r\n    const visited = [];\r\n    start.distance = 0;\r\n    const unvisited = getAllNodes(grid);\r\n    while (!!unvisited.length) {\r\n      sortNodesByDistance(unvisited);\r\n      const closest = unvisited.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closest.isWall) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closest.distance === Infinity) return visited;\r\n      closest.isVisited = true;\r\n      visited.push(closest);\r\n      if (closest === end) return visited;\r\n      updateUnvisitedNeighbors(closest, grid);\r\n    }\r\n  }\r\n  \r\n  function sortNodesByDistance(unvisited) {\r\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dj';\r\n\r\nimport './PathfinderVisualizer.css';\r\n\r\nconst START_NODE_ROW = 7;\r\nconst START_NODE_COL = 10;\r\nconst FINISH_NODE_ROW = 7;\r\nconst FINISH_NODE_COL = 30;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({grid: newGrid, mouseIsPressed: true});\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({grid: newGrid});\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({mouseIsPressed: false});\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-shortest-path';\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    const {grid} = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n\r\n    return (\r\n      <>\r\n        <button className=\"Button\" onClick={() => this.visualizeDijkstra()}>\r\n          Visualize Dijkstra's Algorithm\r\n        </button>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {row, col, isFinish, isStart, isWall} = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 16; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 40; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};","import React from 'react';\nimport './App.css';\nimport PathfinderVisualizer from './PathfinderVisualizer/PathfinderVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfinderVisualizer></PathfinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}